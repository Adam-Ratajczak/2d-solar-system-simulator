#pragma once

#include "Object.hpp"
#include "WrappedObject.hpp"
#include "pyport.h"
#include <string>
#include <type_traits>
#include <utility>

namespace PySSA {

namespace Arg {

template<class UnderlyingT>
struct CheckedType {
    UnderlyingT*& result;
};

template<class T>
requires(!std::is_reference_v<T>) struct Arg {
    char const* keyword = "";
    T arg;

    Arg(T arg_, char const* keyword_ = "")
        : arg(std::forward<T>(arg_))
        , keyword(keyword_) { }
};

};

namespace Detail {

template<class... Ts>
struct ParameterPack { };

// A struct that stores information required to convert C++ type to Python type
// (and the argument itself).
template<class CppType>
struct ConvertToPy {
    static constexpr size_t PyArgCount = 1;
};

// A struct that returns a Python argument from ConvertToPy dependinf
template<class T, size_t Index>
struct GetArg {
    using CTP = ConvertToPy<T>;
};

// Check if a type can be used as target for Python arguments.
template<class CppType>
concept IsConvertibleToPython = requires(ConvertToPy<CppType> ctp, CppType cppt) {
    ctp.PyArgCount;
    // ctp.write_arg(cppt);
};

// Specializations of ConvertToPy for every supported type.
template<class UnderlyingT>
requires(std::is_base_of_v<WrappedObject<UnderlyingT>, UnderlyingT>) struct ConvertToPy<Arg::CheckedType<UnderlyingT>> {
    PyObject* pyobject;
    static constexpr size_t PyArgCount = 2;

    void write_arg(Arg::CheckedType<UnderlyingT> ut) const {
        ut.result = UnderlyingT::get(Object::share(pyobject));
    }
};

template<>
struct ConvertToPy<std::string*> {
    const char* data;
    static constexpr size_t PyArgCount = 1;

    void write_arg(std::string* ut) const {
        *ut = data;
    }
};

// Specializations of GetArg
template<class UT>
struct GetArg<Arg::CheckedType<UT>, 0> {
    static constexpr auto get(auto& ctp) {
        return &UT::type_object();
    }
};

template<class UT>
struct GetArg<Arg::CheckedType<UT>, 1> {
    static constexpr auto get(auto& ctp) {
        return &ctp.pyobject;
    }
};

template<>
struct GetArg<std::string*, 0> {
    static constexpr auto get(auto& ctp) {
        return &ctp.data;
    }
};

// A struct which contains args to be written by PyArg_ParseTuple()
template<class T, class... Ts>
requires IsConvertibleToPython<T>
class ConvertToPyAll : public ConvertToPyAll<Ts...> {
protected:
    using ThisCTP = ConvertToPy<T>;
    ThisCTP value;
    using Base = ConvertToPyAll<Ts...>;
    using BaseCTP = typename Base::ThisCTP;

public:
    template<size_t Index>
    constexpr auto get_arg() {
        if constexpr (Index >= BaseCTP::PyArgCount)
            return Base::template get_arg<Index - BaseCTP::PyArgCount>();
        else
            return GetArg<T, Index>::get(value);
    }
    template<size_t Index>
    constexpr void write_arg(T& out) const {
        if constexpr (Index >= BaseCTP::PyArgCount)
            Base::template write_arg<Index - BaseCTP::PyArgCount>(out);
        else
            value.write_arg(out);
    }
};

template<class T>
requires IsConvertibleToPython<T>
class ConvertToPyAll<T> {
protected:
    using ThisCTP = ConvertToPy<T>;
    ThisCTP value;

public:
    template<size_t Index>
    constexpr auto get_arg() {
        static_assert(Index < ThisCTP::PyArgCount);
        return GetArg<T, Index>::get(value);
    }
    template<size_t Index>
    constexpr void write_arg(T& out) const {
        static_assert(Index < ThisCTP::PyArgCount);
        value.write_arg(out);
    }
};

// A function template which returns a Python arg for a specified index.
template<size_t Index, class... Ts>
constexpr decltype(auto) get_arg_for_pyarg_parsetuple(ConvertToPyAll<Ts...>& py_args) {
    return py_args.template get_arg<Index>();
}

template<class T, class... Ts>
constexpr size_t count_py_args() {
    size_t s = ConvertToPy<T>::PyArgCount;
    if constexpr (sizeof...(Ts) > 0)
        s += count_py_args<Ts...>();
    return s;
};

// Call PyArg_ParseTuple with arguments generated by ConvertToPyAll.
template<typename...>
struct CallPyArgImpl {
};

template<size_t... Is, class... Ts>
struct CallPyArgImpl<std::index_sequence<Is...>, Ts...> {
    static bool run(PyObject* args_object, PyObject* kwargs_object, char const* format, ConvertToPyAll<Ts...>& py_args, const char* keywords[]) {
        return PyArg_ParseTupleAndKeywords(args_object, kwargs_object, format, const_cast<char**>(keywords),
            get_arg_for_pyarg_parsetuple<Is>(py_args)...);
    }
};

template<class... Ts>
bool call_pyarg_parsetuple(PyObject* args_object, PyObject* kwargs_object, const char* format, ConvertToPyAll<Ts...>& py_args, const char* keywords[]) {
    return CallPyArgImpl<std::make_index_sequence<count_py_args<Ts...>()>, Ts...>::run(args_object, kwargs_object, format, py_args, keywords);
}

// Set user output to values returned by PyArg_ParseTuple and stored in ConvertToPyAll.
template<typename...>
struct WriteArgImpl {
};

template<size_t... Is, class... Ts>
struct WriteArgImpl<std::index_sequence<Is...>, Ts...> {
    static void run(ConvertToPyAll<Ts...> const& py_args, Ts... out) {
        (py_args.template write_arg<Is>(out), ...);
    }
};

template<class... Ts>
void write_args(ConvertToPyAll<Ts...> const& py_args, Ts... out) {
    return WriteArgImpl<std::make_index_sequence<sizeof...(Ts)>, Ts...>::run(py_args, out...);
};

}

template<class... Types>
bool parse_arguments(Object const& args_object, Object const& kwargs_object, char const* format, Arg::Arg<Types>... out) {
    Detail::ConvertToPyAll<Types...> py_args;
    const char* keywords[] {
        out.keyword...,
        nullptr
    };
    auto result = Detail::call_pyarg_parsetuple(
        args_object.python_object(),
        kwargs_object.python_object(),
        format,
        py_args,
        keywords);
    if (!result)
        return false;
    Detail::write_args(py_args, out.arg...);
    return true;
}

}
