#pragma once

#ifdef ENABLE_PYSSA

#include "Object.hpp"
#include "WrappedObject.hpp"
#include <string>
#include <type_traits>
#include <utility>

namespace PySSA {

namespace Arg {

template<class UnderlyingT>
struct CheckedType {
    UnderlyingT*& result;
};

template<class T>
requires(!std::is_reference_v<T>) struct Arg {
    char const* keyword = "";
    T arg;

    Arg(T arg_, char const* keyword_ = "")
        : arg(std::forward<T>(arg_))
        , keyword(keyword_) {
            // std::cout << keyword_ << " " << typeid(arg).name() << "\n";
        }
};

};

namespace Detail {

template<class... Ts>
struct ParameterPack { };

// Format String Checker
template<typename... Args>
void compiletime_fail(Args...);

// A struct that stores information required to convert C++ type to Python type
// (and the argument itself).
template<class CppType>
struct ConvertToPy {
    static constexpr size_t PyArgCount = 1;
};

// A struct that returns a Python argument from ConvertToPy dependinf
template<class T, size_t Index>
struct GetArg {
    using CTP = ConvertToPy<T>;
};

// Check if a type can be used as target for Python arguments.
template<class CppType>
concept IsConvertibleToPython = requires(ConvertToPy<CppType> ctp, size_t& index, char const* format_string) {
    ctp.PyArgCount;
    // ctp.write_arg(cppt);
    { ConvertToPy<CppType>::check_format_string(index, format_string) } -> std::same_as<bool>;
};

// Specializations of ConvertToPy for every supported type.
template<class UnderlyingT>
requires(std::is_base_of_v<WrappedObject<UnderlyingT>, UnderlyingT>) struct ConvertToPy<Arg::CheckedType<UnderlyingT>> {
    PyObject* pyobject;
    static constexpr size_t PyArgCount = 2;

    void write_arg(Arg::CheckedType<UnderlyingT> ut) const {
        ut.result = UnderlyingT::get(Object::share(pyobject));
    }

    static consteval bool check_format_string(size_t& index, char const* format_string) {
        if (format_string[index++] != 'O')
            return false;
        if (format_string[index++] != '!')
            return false;
        return true;
    }
};

template<>
struct ConvertToPy<std::string*> {
    const char* data;
    static constexpr size_t PyArgCount = 1;

    void write_arg(std::string* ut) const {
        *ut = data;
    }

    static consteval bool check_format_string(size_t& index, char const* format_string) {
        if (format_string[index++] != 's')
            return false;
        return true;
    }
};

// Specializations of GetArg
template<class UT>
struct GetArg<Arg::CheckedType<UT>, 0> {
    static constexpr auto get(auto& ctp) {
        return &UT::type_object();
    }
};

template<class UT>
struct GetArg<Arg::CheckedType<UT>, 1> {
    static constexpr auto get(auto& ctp) {
        return &ctp.pyobject;
    }
};

template<>
struct GetArg<std::string*, 0> {
    static constexpr auto get(auto& ctp) {
        return &ctp.data;
    }
};

// A struct which contains args to be written by PyArg_ParseTuple()
template<class T, class... Ts>
requires IsConvertibleToPython<T>
class ConvertToPyAll : public ConvertToPyAll<Ts...> {
protected:
    using ThisCTP = ConvertToPy<T>;
    ThisCTP value;
    using Base = ConvertToPyAll<Ts...>;
    using BaseCTP = typename Base::ThisCTP;

public:
    template<size_t Index>
    constexpr auto get_arg() {
        if constexpr (Index >= BaseCTP::PyArgCount)
            return Base::template get_arg<Index - BaseCTP::PyArgCount>();
        else
            return GetArg<T, Index>::get(value);
    }
    template<size_t Index>
    constexpr void write_arg(T& out) const {
        if constexpr (Index >= BaseCTP::PyArgCount)
            Base::template write_arg<Index - BaseCTP::PyArgCount>(out);
        else
            value.write_arg(out);
    }
};

template<class T>
requires IsConvertibleToPython<T>
class ConvertToPyAll<T> {
protected:
    using ThisCTP = ConvertToPy<T>;
    ThisCTP value;

public:
    template<size_t Index>
    constexpr auto get_arg() {
        static_assert(Index < ThisCTP::PyArgCount);
        return GetArg<T, Index>::get(value);
    }
    template<size_t Index>
    constexpr void write_arg(T& out) const {
        static_assert(Index < ThisCTP::PyArgCount);
        value.write_arg(out);
    }
};

// A function template which returns a Python arg for a specified index.
template<size_t Index, class... Ts>
constexpr decltype(auto) get_arg_for_pyarg_parsetuple(ConvertToPyAll<Ts...>& py_args) {
    return py_args.template get_arg<Index>();
}

template<class T, class... Ts>
constexpr size_t count_py_args() {
    size_t s = ConvertToPy<T>::PyArgCount;
    if constexpr (sizeof...(Ts) > 0)
        s += count_py_args<Ts...>();
    return s;
};

// Call PyArg_ParseTuple with arguments generated by ConvertToPyAll.
template<typename...>
struct CallPyArgImpl {
};

template<size_t... Is, class... Ts>
struct CallPyArgImpl<std::index_sequence<Is...>, Ts...> {
    static bool run(PyObject* args_object, PyObject* kwargs_object, char const* format, ConvertToPyAll<Ts...>& py_args, const char* keywords[]) {
        return PyArg_ParseTupleAndKeywords(args_object, kwargs_object, format, const_cast<char**>(keywords),
            get_arg_for_pyarg_parsetuple<Is>(py_args)...);
    }
};

template<class... Ts>
bool call_pyarg_parsetuple(PyObject* args_object, PyObject* kwargs_object, const char* format, ConvertToPyAll<Ts...>& py_args, const char* keywords[]) {
    return CallPyArgImpl<std::make_index_sequence<count_py_args<Ts...>()>, Ts...>::run(args_object, kwargs_object, format, py_args, keywords);
}

// Set user output to values returned by PyArg_ParseTuple and stored in ConvertToPyAll.
template<typename...>
struct WriteArgImpl {
};

template<size_t... Is, class... Ts>
struct WriteArgImpl<std::index_sequence<Is...>, Ts...> {
    static void run(ConvertToPyAll<Ts...> const& py_args, Ts... out) {
        (py_args.template write_arg<Is>(out), ...);
    }
};

template<class... Ts>
void write_args(ConvertToPyAll<Ts...> const& py_args, Ts... out) {
    return WriteArgImpl<std::make_index_sequence<sizeof...(Ts)>, Ts...>::run(py_args, out...);
};

// more Format String Checker ...
template<class... Ts>
class CheckedFormatStringImpl {
public:
    template<size_t N>
    consteval CheckedFormatStringImpl(char const (&v)[N])
        : m_value(v)
        , m_value_len(N) {
        check_format_string();
    }

    constexpr char const* value() const { return m_value; }

private:
    char const* m_value {};
    size_t m_value_len = 0;

    template<class T>
    consteval void consume_arg(size_t& index) const {
        if (index >= m_value_len - 1)
            compiletime_fail("Too much args specified");
        // Always expect and ignore | (optional start) or $ (kwargs start)
        // TODO: Parse them properly (e.g expect only one, etc.)
        while (m_value[index] == '|' || m_value[index] == '$')
            ++index;
        if (!ConvertToPy<T>::check_format_string(index, m_value)) {
            // TODO: Better error message, but this is not zig when I can get
            //       types as strings
            compiletime_fail("Invalid format");
        }
    }

    consteval void check_format_string() const {
        size_t index = 0;
        (consume_arg<Ts>(index), ...);
        // '|$' also at the end
        while (m_value[index] == '|' || m_value[index] == '$')
            ++index;
        if (index != m_value_len - 1) {
            compiletime_fail("Not enough args given");
        }
    }
};

template<typename... Args>
using CheckedFormatString = CheckedFormatStringImpl<std::type_identity_t<Args>...>;

}

template<class... Types>
constexpr bool parse_arguments(Object const& args_object, Object const& kwargs_object, Detail::CheckedFormatString<Types...>&& format, Arg::Arg<Types>... out) {
    Detail::ConvertToPyAll<Types...> py_args;
    const char* keywords[] {
        out.keyword...,
        nullptr
    };
    auto result = Detail::call_pyarg_parsetuple(
        args_object.python_object(),
        kwargs_object.python_object(),
        format.value(),
        py_args,
        keywords);
    if (!result)
        return false;
    Detail::write_args(py_args, out.arg...);
    return true;
}

}

#endif
